Done conditions:
 - Transactions.
 - Encoding which is compatible with some other database.
 - Protocol which can be benchmarked.
// think about this pretty heavily

Want:
 - Error tracing.
 - Debug settings to log:
   - KV calls.
   - Query parses.
 - A dedicated log package.
 - To move the store keys from strings to bytes.
 - To think long and hard about when to use the word Key, and when to use the word ID.
 - Prettifying of keys on request.
 - A sql query planner.
 - WAL backing for the store.

2025-04-06
 - Try to implement some select, and rendering functionality
 - Try to get selecting to work.

For rendering, how should I render the header of some output?

If the rows themselves are devoid of header information, how d othey render at the end? How does toydb do it?

How should I render tabular result data?

insert planning and execution mostly works. most of the edges of all of this are untested, and the functionality itself seems reallly shakey.

that being said it looks good when it's running, so it's a positive start.

In insert execution, I'm already missing some pretty basic functionality, that being the validation of column values, primary key setting (when the user hasn't set a primary key), and some other things.

Debugging is getting a little hairy. There are times when I only want to debug parts, the keys in storage or the nodes of the parser. Might make debugging a bit more involved in the future.

Organizing the project has been challenging, especially since lots of packages share common themes (sequence, table, create table, etc)

Transactions, especially transaction execution with sequences has me a bit befuddled. I'm not sure how to all or one things in this particular layout.

2025-04-06
 - Lots of additional tests for the parser.

2025-04-05
 - implement the insert functionality
 - Remove references from the codebase (for now)

2025-04-01
 - Create a plan for insert that works
 - Create a debugger for plans

2025-03-30
 - DescriptorBuilders
 - Fix where sequence generation occurs

2025-03-28
 - Generic Manager
 - Bootstrapping
  - Reorganize logic to bootstrap from system objects

2025-03-27
 - Keys
  - Key part to bytes
    - This is quite doable
  - Delimiter
    - Null byte should work if delimited by bytes
  - Prefixes
    - Worth having a prefix class?
    - Might not be
  - Encoding
  - Decoding
  - Escaping unique values
  - How is prefix end handled?
  - Referring to Spans rather than ranges


having a debug store wrapper

type DebugStore interface {
  
}


type Prefix struct {
 Table *desc.Table
}

type Key []byte

func (k Key) Pretty (sc *schema.Schema) {
 
}

 I really do like the idea of being able to put registers. Things which have Key(), Value() functionality.

Even in relational databases, keys refer to two things, the absolute key of the item, stored in the keyspace, and its relative / index key, the tail of an absolute key.

type Register interface {
  Key() *keys.Key
}

interface Key {
 Key() string
}

type Datum struct {
 Values []any
 Key []int
}

keys.Prefix(Table)
prefix.Key(Keyable)

If I were to think about using the keys, whatever would I think?

What do I want the surface to look like?
Should store take a register?

What of the concept of a register?

TableRegister
SequenceRegister

2025-03-26
 - Test all new code.

2025-03-23
 - Clean up manager package.
 - Get everything wired up to create new tables.
 - Reorganize packages for schema management / description.

