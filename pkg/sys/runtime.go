package sys

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/angles-n-daemons/popsql/pkg/sql/parser/ast"
	"github.com/google/uuid"
)

const PRIMARY_KEY_NAME = "_internal_pk"

type Payload struct {
	Table *Table
	// columns and data are theoretically ordered
	Columns []*Column
	Data    []any
}

func NewPayloadFromExpression(
	table *Table, colRefs []*ast.Reference, tuple []ast.Expr,
) (*Payload, error) {
	// need two things for a primary key
	// 1. a primary key column on create table
	//    created on create
	// 2. a hidden, autogenerated primary key value injected into the set if not specified
	//    occurs on new payload if the key is an autogen column
	// may be worth investigating integer autoincrement columns otherwise

	// special case if there are no colRefs, use the table columns
	if len(colRefs) != len(tuple) {
		return nil, fmt.Errorf("value set found incorrect size expected %d found %d", len(colRefs), len(tuple))
	}
	columns := []*Column{}
	for i, col := range colRefs {
		column, err := table.GetColumnFromRef(col)
		if err != nil {
			return nil, err
		}
		columns[i] = column
	}
	data := []any{}
	for _, value := range tuple {
		// validate data type
		// how to handle references?
		// only handle simple data types
		switch v := value.(type) {
		case *ast.Literal:
			data = append(data, v.Value.Literal)
		default:
			return nil, fmt.Errorf("unexpected expression type %T reading VALUES", value)
		}
	}
	return &Payload{Table: table, Columns: columns, Data: data}, nil
}

func (p *Payload) Key() string {
	pk := p.Table.PrimaryKey
	if len(pk) == 0 {
		panic(fmt.Errorf("no primary key for table %s", p.Table.Name))
	}
	// calculate ordinal position of key
	// should this be precomputed?
	pkm := map[string]int{}
	for i, key := range pk {
		pkm[key] = i
	}
	keys := make([]string, len(pk))
	found := 0
	for i, col := range p.Columns {
		if j, ok := pkm[col.Name]; ok {
			val, ok := p.Data[i].(string)
			if !ok {
				panic(fmt.Errorf("primary key value %s expected string but got type %T", col.Name, p.Data[i]))
			}
			found++
			keys[j] = val
			delete(pkm, col.Name)
		}
	}
	if len(pkm) > 0 {
		panic(fmt.Errorf("missing key values %v in record", pkm))
	}
	return strings.Join(keys, ":")
}

func (p *Payload) ToBytes() ([]byte, error) {
	var record = map[string]any{}
	for i, col := range p.Columns {
		record[col.Name] = p.Data[i]
	}
	return json.Marshal(record)
}

func MaybeAddAutogenKey(table *Table, columns []*Column, data []any) error {
	// should not reach this state
	if len(table.PrimaryKey) == 0 {
		return fmt.Errorf("no primary keys found for this table")
	}
	// primary key cannot be auto gen if more than one column
	if len(table.PrimaryKey) > 1 {
		return nil
	}
	// only autogen if primary key is the autogen primary key
	pk := table.PrimaryKey[0]
	if pk != PRIMARY_KEY_NAME {
		return nil
	}
	column, err := table.GetColumn(PRIMARY_KEY_NAME)
	if err != nil {
		return err
	}
	columns = append(columns, column)
	data = append(data, uuid.New())
	return nil
}
